##动态生成（函数）对象
转自[子曰博客](http://www.afewords.com/blog/5066b96437251776c4000006)


很多人都会疑惑，Python对于函数闭包的支持意味着什么？

要理解这个问题，我们就要先明白一点：函数闭包到底增加了什么？

函数闭包提供了函数对象一个运行环境。这时的函数对象得以和上下文环境一起传递，函数也就具有了状态，不同的状态可以导致函数拥有不同的行为。典型的例子如下：

	def with_cnt(funcobj):
	    cnt = [0]
	    def wrapper(*args, **kwargs):
	        cnt[0] += 1
	        print cnt[0]
	        return funcobj(*args, **kwargs)
	    return cnt

上面的函数with_cnt接收一个函数对象，它返回一个新的函数对象，这个新的函数对象和原来传进去的功能一样，只是多了一个打印自己被调用次数的功能。

当然，我写这篇文章的重点不在于阐述返回的函数闭包本身，而在于它的生成能力，即类似上面所写的with_cnt这样的函数所做的工作。

函数生成

如果你需要写大量功能类似的函数，你是不是会觉得很苦恼，因为这些代码如此相似，你却不得不全部输入一遍。而如果引入一个更多参数的函数，又会影响函数的接口美观性，你是否觉得这样的工作总是如此的枯燥？

当然，办法不是没有。有很多出色的脚本语言，可以很方便的批量的生成代码，你只需要粘贴他们即可。但是...你需要修改这些函数呢？真是令人崩溃的过程～～

如果有一个函数，它能返回你需要的这些函数呢？没错，函数闭包使得这些成为了可能，因为函数可以根据自己的闭包所携带的状态决定自己的功能，你可以轻易的生成你需要的这些函数对象。

在此处，我不得不把这些函数生成器分成两类——装饰器和工厂函数，因为它们从功能上来说确实有着显著的不同。

###装饰器  

顾名思义，它完成修饰工作，它一般接受一个函数对象。**返回的对象和原对象实现功能基本一样，不同的是它会做一些额外的工作。**这个过程就如同给糖果包上糖纸一样，事实上，它也是函数闭包最常用的功能之一。

他的实例很多，上面的with_cnt就是一个非常典型的例子，还有Python中有大量的修饰符，比如classmethod, staticmethod, property等等，你还可以定义自己的修饰符。这些修饰符可以帮你做很多事情，让你可以暂时放下那些繁琐的初始化环境，仅仅关注你操作的核心逻辑。典型的例子

+ 数据库的自动连接。你可以把函数传入一个装饰器使得它自动携带一个连接。
+ 用户权限认证。你无需担心认证的细节，因为你可以把你的函数传入一个修饰器，使得你的函数自动携带一个认证过程，在认证完成之后才执行原来函数的功能。

	def with_conn(operation): 
	    pool = get_pool() #这个pool是一个单例，get_pool()每次返回同一个pool对象。 
	    def wrapper(*args, **kwargs): 
	        conn = pool.get_conn() 
	        ans = operation(conn, *args, **kwargs) #随便写的，应该能理解吧:) 
	        conn.back_to_pool(pool) 
	        return ans 
	    return wrapper 
	
	#with_conn可以作为装饰器用，虽然不是非常严格（它改变原始函数的调用参数，或者说自动绑定第一参数，类似实例对象的bound method的情况）
	@with_conn
	def get_item(conn, *args, **kwargs):
	    return get_item_from_db(conn, *someparas_here) 
	    #象征性的写了个，这里get_item_from_db一般都不会太短

当然，如果传入的仅仅只能是函数的话，它还不至于如此强大。真正强大的地方在于，它可以传入其它对象。能够被修饰的绝非函数而已。并且，和函数对象不同（函数对象一般只能被调用），类对象和实例对象的属性一般是可以被修改的（这里展开可以说很多，当然，我没打算这么做:) 当你需要它们的时候，自然会明白）

###工厂函数  

这类函数在你传入参数之后返回给你一个你需要的函数对象，它没有一个包装的过程。当然，**返回的对象可以不是函数，也可以是类的实例**。至于效果，如果你以前有了解面向对象的多态性质的话，我想你能明白这意味着什么。即便没有太多了解，也应该有听说过多态这个名词吧。而且，工厂函数的功能非常适合用来动态生成“代码”，用得好的话，甚至可以作为自动编程的机器:)

下面给出一个典型的例子。


	from datetime import datetime
	
	def funcnow_tz(tz):
	    def funcnow():
	        return datetime().now(tz)
	    return funcnow

当你需要一个函数对象，你调用它的时候，它会返回一个对应时区的当前时间，上面这个函数funcnow_tz就可以完成该函数的生成工作。

也许你会问，为什么不把时区直接传入，像datetime.now(tz)这样调用呢（就如同funcnow_tz里面确实写的那样）？

这个问题很自然。我想说的是，那么做确实有效，毕竟用Python能实现的，C也一样可以做，但是，实现的接口上我觉得还是Python的方式更加自然。如果你要把时区信息从数据库传到前面，中间可能需要经过不少层，然后，在最后的时候你还要手动的取时区的数据，然后再调用下datetime.now，这确实不是非常优雅，毕竟在前面使用这个调用的未必是你自己，**隐藏尽可能多的对方不需要知道的细节是有很多好处的**。如果你交给前台的是一个函数对象，问题就不一样了。它不用管传过来的数据里面有没有时区信息，因为他只要调用下这个对象就可以了，甚至连名字都不用知道。

其实在上面这个例子中，传递参数的方式，我们可以认为是以数据为接口的编程方式。它依赖于很多数据接口约定，也很难对前面隐藏数据细节（其实是不可能的，因为数据本身就是接口），如果你的数据存储方式更改了的话，后续的更新代价可能就是噩梦了。这个时候，把那些你不需要让前面知道的属性，封装进对象，让这些属性自动的决定对象的执行方式，你就能真正的做到前后隔离。工厂函数使得这种实现可以如此轻易地就实现完成，何乐而不为呢:)

然后，我上面说的这些，其实就是多态的特性。在Python中的多态确实总是如此的简单而直接，以至于并不需要特殊强调它。你需要明白的重点是，函数或者对象的名字，那从来不是重点。重点是你把它传递出去之后，它提供了给定的接口，能够完成它的功能即可。调用者无需知道这个对象是什么，简单的调用它就行（如果是对象的话，一般需要先定义公共接口）。

###总结

我并不希望上面的分类局限了你的思维，它们仅仅是两个非常有用的技巧。而函数是一种如此自由的结构，你可以用它构造很多神奇的功能（这种构造能力同样适用于其它可调用的对象，其实Python的很多装饰器并非函数，很可能是类对象甚至是可调用的实例对象）。多范式的Python和纯面向对象的语言相比，使用起来往往要简单得多，因为函数作为一种轻量级的结构，比类和对象要好写很多，非常适合构建多层次的模型。

请关注那些可以调用的东西，并且，请不要太在意它们的名字:)
和数据相比，那些可以调用的东西往往更好用。相比那些拥有参数的调用，无参调用往往更好用:)


###Comment 

+ 关注闭包携带状态特性加以利用，如数据库的连接